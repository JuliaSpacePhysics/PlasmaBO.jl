var documenterSearchIndex = {"docs":
[{"location":"dispersion_surface/#Case:-Dispersion-surface-tracking-(2D-scan)","page":"Dispersion surface tracking","title":"Case: Dispersion surface tracking (2D scan)","text":"This page demonstrates how to construct a dispersion surface by scanning a 2D parameter space (wave number k and propagation angle θ) and using branch tracking to follow a consistent mode across the scan.\n\nWe consider a typical electron–proton plasma and scan:\n\nk in normalized units k/k_n, where k_n = ω_pi/c\nθ from 5° to 90°\n\nusing PlasmaBO\nusing PlasmaBO: c0\n\nB0 = 5e-9 # [Tesla]\n\nn = 5.0e6\nT = 12.94\n\nion = Maxwellian(:p, n, T)\nelectron = Maxwellian(:e, n, T)\nspecies = (ion, electron)\n\nwn = abs(B0 * ion.q / ion.m)\nwpi = plasma_frequency(ion.q, n, ion.m)\nkn = wpi / c0\nwci = wn\n\n# Kinetic solver settings (adjust upward for accuracy)\nN = 3","category":"section"},{"location":"dispersion_surface/#Dispersion-Curve-Scan","page":"Dispersion surface tracking","title":"Dispersion Curve Scan","text":"using CairoMakie\n\nθ = deg2rad(45);\nk_ranges = (0.01:1:100) .* kn;\nresults = solve_kinetic_dispersion(species, B0, k_ranges, θ; N)\n\nplot(results, kn, wn)\n\nusing PlasmaBO: plot_branches\n\n# k, ω pairs for initial branch points (see `BranchPoint` for more control over tracking)\ninitial_point = (50 * kn, -600 * wn *im)\nbranch = track(results, initial_point)\nf, (ax1, ax2) = plot_branches((branch,), kn, wn)\nylims!(ax2, -3500,500)\nf","category":"section"},{"location":"dispersion_surface/#Dispersion-Surface-Scan-(2D)","page":"Dispersion surface tracking","title":"Dispersion Surface Scan (2D)","text":"ks = (0.1:10:100.0) .* kn;\nθs = deg2rad.(10.0:10.0:90.0);\nres2d = solve_kinetic_dispersion(species, B0, ks, θs; N)\n\nplot(res2d, kn, wn; figure=(; size=(800, 300)))\n\n# Choose a reference angle and reference k for seeding the tracked mode\nseed = (90.5 * kn, deg2rad(20), (1000 - 3000im) * wn)\nbranch = track(res2d, seed)\nplot_branches((branch,), kn, wn; figure=(; size=(800, 300)))","category":"section"},{"location":"ice_Irvine18/#Case:-Ion-cyclotron-emission","page":"Ion cyclotron emission","title":"Case: Ion cyclotron emission","text":"Ion cyclotron emission (ICE) driven by a ring ion beam distribution in a magnetized fusion device\n\nusing PlasmaBO\nusing PlasmaBO: gyrofrequency, Alfven_speed\n\nusing DelimitedFiles\n\n# Magnetic field (Tesla)\nB0 = 2.1\n\n# Wave vector angle between k and B0\nθ = deg2rad(89.5)\n\n# Species table taken from the original BO MATLAB input\nfpath = pkgdir(PlasmaBO, \"test/ice_Irvine18.in\")\nreaddlm(fpath)","category":"section"},{"location":"ice_Irvine18/#Dispersion-Curve-Scan","page":"Ion cyclotron emission","title":"Dispersion Curve Scan","text":"tbl = readdlm(fpath, Float64; skipstart = 1)\nspecies = map(eachrow(tbl)) do row\n    Z, A, n_s, Tz_s, Tp_s, vdz_s, vdr_s = row[1:7]\n    Maxwellian(n_s, Tz_s, Tp_s; vdz = vdz_s, vdr = vdr_s, Z , A)\nend\n\nωn = gyrofrequency(B0, species[1])\nvA = Alfven_speed(B0, species)\nkn = ωn / vA\n\nks = (9.5:0.025:11.5) .* kn\nresults = solve_kinetic_dispersion(species, B0, ks, θ; N = 12, J = 4)\n\nusing CairoMakie\n\nf, (ax, ax2) = plot(results, kn, ωn)\nylims!(ax, [0, 15])\nylims!(ax2, [-0.5, 0.5])\nf","category":"section"},{"location":"mirror_mode/#Case:-Mirror-mode","page":"Mirror mode","title":"Case: Mirror mode","text":"The benchmark is based on Gary (1993), p131, Fig.7.4, with\n\nPropagation angle: θ = 71°\nBeta ratio: β_iβ_e = 1\nTemperature anisotropy:\nions: T_iT_i = 2\nelectrons: T_eT_e = 1\nMagnetic field: B_0 = 100e-9 T\nSpecies:\nq = -1, m = 1/1836, n = 1e6, T∥ = 24840 eV, T⊥ = 24840 eV, v0 = 0\nq = +1, m = 1, n = 1e6, T∥ = 24840 eV, T⊥ = 49680 eV, v0 = 0\n\nusing PlasmaBO\n\nB0 = 100e-9\nθ = deg2rad(71)\n\nn = 1e6\nme_mp = 1 / 1836\n\nelectron = Maxwellian(:e, n, 24840.0)\nproton   = Maxwellian(n, 24840.0, 49680.0)\n\nspecies = (proton, electron)\nparams = HHSolverParam.(species, B0)\nρᵢ = params[1].ρc\nωₙ = params[1].wc\nks = (0.005:0.04:0.7) ./ ρᵢ\n\nsol = solve_kinetic_dispersion(species, B0, ks, θ)\n\n# Extract the most unstable mode at each k (by growth rate)\nωmax = argmax.(imag, sol.ωs)\n\nusing CairoMakie\n\nlet fig = Figure()\n    ax1 = Axis(fig[1,1]; xlabel = \"k*λD\", ylabel = \"ωᵣ / ωₙ\")\n    ax2 = Axis(fig[1,2]; xlabel = \"k*λD\", ylabel = \"γ / ωₙ\")\n    scatterlines!(ax1, sol.ks .* ρᵢ, real.(ωmax)./ ωₙ)\n    scatterlines!(ax2, sol.ks .* ρᵢ, imag.(ωmax)./ ωₙ)\n    fig\nend","category":"section"},{"location":"ringbeam_Umeda12/#Case:-Ring-beam-instability","page":"Ring beam instability","title":"Case: Ring beam instability","text":"This page demonstrates how to use the package to solve kinetic dispersion relations for the ring beam instability Umeda et al. [7].\n\nusing PlasmaBO\nusing PlasmaBO: q, me\nusing Unitful\n\n# Umeda 2012 ring beam configuration\nB0 = 96.24e-9  # [Tesla]\n\nT = 51u\"eV\"\n# Ring beam electrons (10% density)\n# The first argument (optional) indicates particle type of the distribution (by default we use `proton`)\nring_beam = Maxwellian(:e, 1e5, T; vdz=0.1, vdr=0.05)\n# Background electrons (90% density)\nbackground = Maxwellian(:e, 9e5, T)\n\nspecies = [ring_beam, background]\n\n# Compute normalization\nwce = abs(B0 * q / me)\nlambdaD = Debye_length(species)\nkn = 1 / lambdaD\n\n# Wave vector: k*λD = 0.03, θ = 40°\nk = 0.03 / lambdaD\nθ = deg2rad(40)\nkx = k * sin(θ)\nkz = k * cos(θ)\n\n# J=12 provides good accuracy (J-pole approximation order)\nωs = solve_kinetic_dispersion(species, B0, kx, kz; N=6, J=12)\n\n# Filter for unstable modes (ω/ωce) with positive growth rate\nω_unstable = filter(ω -> isfinite(ω) && imag(ω) > 0.001*wce, ωs)[1] ./wce","category":"section"},{"location":"ringbeam_Umeda12/#Dispersion-Curve-Scan","page":"Ring beam instability","title":"Dispersion Curve Scan","text":"Scan k*λD from 0.01 to 0.3\n\nk_ranges = (0.01:0.005:0.3) .* kn;\nsol = solve_kinetic_dispersion(species, B0, k_ranges, θ; N=6)\n\n# k, ω pairs for initial branch points (see `BranchPoint` for more control over tracking)\ninitial_points = [\n    (0.1 * kn, 0.3im * wce),\n    (0.1 * kn, 0.1im * wce),\n    (0.2 * kn, 0.25im * wce)\n]\n\nbranches = track.(sol, initial_points)\n\n# Extract individual branches\nfor (i, (k_branch, ω_branch)) in enumerate(branches)\n    println(\"Branch $i:\")\n    println(\"  k range: $(minimum(k_branch)) to $(maximum(k_branch))\")\n    println(\"  Max growth rate: γ = $(maximum(imag.(ω_branch)))\")\nend\n\nPlot all branches\n\nusing CairoMakie\n\nplot_branches(branches, kn, wce)","category":"section"},{"location":"cold_plasma/#Case:-Cold-plasma-(kinetic-vs-fluid)","page":"Cold plasma (fluid vs kinetic solver)","title":"Case: Cold plasma (kinetic vs fluid)","text":"This page demonstrates a typical cold plasma configuration (electron–proton plasma) and compares the eigenmodes computed by the kinetic solver (solve_kinetic_dispersion) and the multi-fluid solver (solve_fluid_dispersion).\n\nThe input parameters correspond to the following species table:\n\nspecies n (m⁻³) T (eV)\nions (p) 8.7e6 2.857e-3\nelectrons (e) 8.7e6 2.857e-3\n\nWe scan k at fixed propagation angle θ = 60°.\n\nusing PlasmaBO\nusing PlasmaBO: q, me, mp, c0\n\nB0 = 100e-9 # [Tesla]\nθ = deg2rad(60)\n\nn = 8.7e6\nT = 2.857e-3\n\nion = Maxwellian(:p, n, T)\nelectron = Maxwellian(:e, n, T)\nspecies = (ion, electron)\n# For more control over the fluid model, we can use `FluidSpecies`\n# electron_f = FluidSpecies(:e, n, T; gamma_z = 1.0, gamma_p = 1.0)\n\nwci = abs(B0 * q / mp)\nwpi = plasma_frequency(q, n, mp)\nkn = wpi / c0","category":"section"},{"location":"cold_plasma/#Dispersion-Curve-Scan","page":"Cold plasma (fluid vs kinetic solver)","title":"Dispersion Curve Scan","text":"kn_scan = 0.01:2.0:100.0;\nks = kn_scan .* kn;\nkinetic = solve_kinetic_dispersion(species, B0, ks, θ);\nfluid_ωs = solve_fluid_dispersion(species, B0, ks, θ);\n\nusing CairoMakie\n\nlet\n    fig = Figure(size = (900, 360))\n    ax1 = Axis(fig[1, 1], xlabel = \"k [k_n]\", ylabel = \"Re(ω)/ω_ci\")\n    ax2 = Axis(fig[1, 2], xlabel = \"k [k_n]\", ylabel = \"Im(ω)/ω_ci\")\n\n    for (k_norm, ωs_k, ωs_f) in zip(kn_scan, kinetic.ωs, fluid_ωs.ωs)\n        xk = fill(k_norm, length(ωs_k))\n        xf = fill(k_norm, length(ωs_f))\n\n        scatter!(ax1, xk, real.(ωs_k) ./ wci; color=:transparent, strokecolor = (:blue, 0.35), strokewidth=2, marker = :circle)\n        scatter!(ax1, xf .+ 0.05, real.(ωs_f) ./ wci; color=:red, marker = :cross)\n\n        scatter!(ax2, xk, imag.(ωs_k) ./ wci; color=:transparent, strokecolor = (:blue, 0.35), strokewidth=2, marker = :circle)\n        scatter!(ax2, xf .+ 0.05, imag.(ωs_f) ./ wci; color=:red, marker = :cross)\n    end\n    fig\nend\n\nRed crosses: Fluid solver results.\n\nBlue circles: Kinetic solver results.\n\nThere is a slight difference at large k for the ion cyclotron wave, which is damped due to kinetic effect.","category":"section"},{"location":"#PlasmaBO","page":"Home","title":"PlasmaBO","text":"Documentation for PlasmaBO.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/JuliaSpacePhysics/PlasmaBO.jl\")","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Hermite-Hermite (HH) expansion for arbitrary/analytic distributions\nMaxwellian / BiMaxwellian\nKappa / BiKappa / product Bikappa\nIntegration with ChargedParticles.jl\nMulti-fluid solver","category":"section"},{"location":"#Usage-Examples","page":"Home","title":"Usage Examples","text":"The matrix eigenvalue method (Xie [1], Xie and Xiao [2]) finds all wave modes simultaneously by transforming the dispersion relation into a matrix eigenvalue problem using J-pole approximation for the plasma dispersion function.\n\nThis approach is more efficient to find multiple modes at once, and doesn't require initial guesses for the root finder.\n\nCheck out the ring beam instability example for detailed usage instructions, also see firehose instability example for using with arbitrary velocity distributions, cold plasma example for comparing kinetic and fluid solvers, and dispersion surface tracking example for 2D scanning and mode tracking.","category":"section"},{"location":"#Notation-and-Assumptions","page":"Home","title":"Notation & Assumptions","text":"The formulation (code) is valid for non-relativistic, arbitrary gyrotropic distributions.\n\nCoordinates\nz: direction parallel to the background magnetic field (B0).\nx: one perpendicular direction (any perpendicular direction is equivalent).\nVelocities\nvz, vx: particle velocity components along z and x.\nvdz, vdx: drift/bulk velocity components along z and x (when present in a distribution parameterization).\nvtz, vtx: thermal speeds along z and x.\nWave vector\nθ: propagation angle between k and B0.\nk∥ = k cos(θ), k⊥ = k sin(θ).","category":"section"},{"location":"#References","page":"Home","title":"References","text":"Xie [3], Xie et al. [4], Xie [5], Xie [6], \n\nH. Xie. Efficient Framework for Solving Plasma Waves with Arbitrary Distributions. Physics of Plasmas 32, 60702 (2025).\n\n\n\nH. Xie and Y. Xiao. PDRK: A General Kinetic Dispersion Relation Solver for Magnetized Plasma*. Plasma Science and Technology 18, 97 (2016).\n\n\n\nH. Xie. Rapid Computation of the Plasma Dispersion Function: Rational and Multi-Pole Approximation, and Improved Accuracy. AIP Advances 14, 75007 (2024).\n\n\n\nH.-s. Xie, R. Denton, J.-s. Zhao and W. Liu. BO 2.0: Plasma Wave and Instability Analysis with Enhanced Polarization Calculations (Mar 2021), arXiv:2103.16014 [physics].\n\n\n\nH.-s. Xie. PDRF: A General Dispersion Relation Solver for Magnetized Multi-Fluid Plasma. Computer Physics Communications 185, 670–675 (2014).\n\n\n\nH.-S. (. Xie. Generalized Plasma Dispersion Function: One-Solve-All Treatment, Visualizations, and Application to Landau Damping. Physics of Plasmas 20, 92125 (2013).\n\n\n\nT. Umeda, S. Matsukiyo, T. Amano and Y. Miyoshi. A Numerical Electromagnetic Linear Dispersion Relation for Maxwellian Ring-Beam Velocity Distributions. Physics of Plasmas 19, 72107 (2012).\n\n\n\n","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"#PlasmaBO.BranchPoint","page":"Home","title":"PlasmaBO.BranchPoint","text":"BranchPoint{T}\nBranchPoint(k, ω)\n\nInitial point specification for dispersion branch tracking.\n\nFields\n\nk: Wave vector at initial point\nω: Frequency at initial point\nlocator: Callable used to locate the seed eigenvalue at the initial point\n\nExample\n\n# Track unstable branch starting at k=0.03 with γ=0.1721\npoint1 = BranchPoint(0.03, 0.1721im)     # Auto: track by Im\n\n# Track real frequency mode at k=0.5 with ωᵣ=2.5\npoint2 = BranchPoint(0.5, 2.5)  # Auto: track by Re\n\n\n\n\n\n","category":"type"},{"location":"#PlasmaBO.FluidSpecies","page":"Home","title":"PlasmaBO.FluidSpecies","text":"FluidSpecies(n, Tz, Tp = Tz; vdz=0.0, gamma_z=1.0, gamma_p=1.0, particle=:p, ...)\n\n\n\n\n\n","category":"type"},{"location":"#PlasmaBO.FluidSpecies-2","page":"Home","title":"PlasmaBO.FluidSpecies","text":"FluidSpecies{T}\n\nFluid species parameters for the multi-fluid dispersion relation solver.\n\nFields\n\nq: Charge\nm: Mass\nn: Number density (m⁻³)\nTz: Parallel temperature (eV)\nTp: Perpendicular temperature (eV)\nvdz: Parallel drift velocity (in units of c)\ngamma_z: Parallel polytrope exponent (default: 1.0 for isothermal)\ngamma_p: Perpendicular polytrope exponent (default: 1.0 for isothermal)\n\n\n\n\n\n","category":"type"},{"location":"#PlasmaBO.JPoleCoefficients","page":"Home","title":"PlasmaBO.JPoleCoefficients","text":"JPoleCoefficients{T}\n\nJ-pole approximation coefficients for the plasma dispersion function. Z(ζ) ≈ Σⱼ bⱼ/(ζ - cⱼ)\n\n\n\n\n\n","category":"type"},{"location":"#PlasmaBO.funAn-NTuple{5, Any}","page":"Home","title":"PlasmaBO.funAn","text":"funAn(n, a, d, m, p)\n\nPerpendicular integral for Jn²: ∫ Jn²(ay) exp(-(y-d)²) (y-d)^m y^p dy.\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.funBn-NTuple{5, Any}","page":"Home","title":"PlasmaBO.funBn","text":"funBn(n, a, d, m, p)\n\nPerpendicular integral for Jn·Jn': ∫ Jn(ay) Jn'(ay) exp(-(y-d)²) (y-d)^m y^p dy.\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.funCn-NTuple{5, Any}","page":"Home","title":"PlasmaBO.funCn","text":"funCn(n, a, d, m, p)\n\nPerpendicular integral for (Jn')²: ∫ [Jn'(ay)]² exp(-(y-d)²) (y-d)^m y^p dy.\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.funIn-Tuple{Any}","page":"Home","title":"PlasmaBO.funIn","text":"funIn(n)\n\nNormalization integral I_n = ∫ v^n exp(-v²) dv / √π.\n\nReturns Γ((n+1)/2)/√π for even n, 0 for odd n.\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.get_jpole_coefficients","page":"Home","title":"PlasmaBO.get_jpole_coefficients","text":"get_jpole_coefficients(J=8)\n\nGet J-pole approximation coefficients for the plasma dispersion function.\n\nSupported values: J ∈ {4, 6, 8, 10, 12, 16, 20, 24, 28, 32}\n\n\n\n\n\n","category":"function"},{"location":"#PlasmaBO.hermite_H-Union{Tuple{T}, Tuple{Int64, T}} where T<:Number","page":"Home","title":"PlasmaBO.hermite_H","text":"hermite_H(n::Int, x)\n\nCompute physicists' Hermite polynomial H_n(x) using recurrence relation.\n\nRecurrence Relations\n\nH_0(x) = 1\nH_1(x) = 2x\nH{n+1}(x) = 2x*Hn(x) - 2n*H_{n-1}(x)\n\nExamples\n\nhermite_H(0, 1.5)  # Returns 1.0\nhermite_H(1, 1.5)  # Returns 3.0 (= 2*1.5)\nhermite_H(2, 1.5)  # Returns 7.0 (= 2*1.5*3.0 - 2*1*1.0)\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.hermite_a0_to_a-Tuple{Any}","page":"Home","title":"PlasmaBO.hermite_a0_to_a","text":"hermite_a0_to_a(a0lm)\n\nConvert normalized Hermite basis coefficients: a0lm -> alm\n\nTransforms expansion:\n\nf(z,x) = Σ_{l,m} a0_{l,m} * ρ_l(z) * u_m(x)\n\nto:\n\nf(z,x) = Σ_{l,m} a_{l,m} * g_l(z) * h_m(x)\n\nwhere:\n\nρl, um are normalized Hermite functions\ng_l(z) ∝ z^l * exp(-z²/2)\nh_m(x) ∝ x^m * exp(-x²/2)\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.hermite_coefficients_matrix-Tuple{Any}","page":"Home","title":"PlasmaBO.hermite_coefficients_matrix","text":"hermite_coefficients_matrix(nmax)\n\nCompute coefficient matrix for expanding Hermite polynomials in power basis given the maximum order nmax.\n\nReturns matrix cHn[n+1, k+1] such that:\n\nH_n(x) / √(2^n n! √π) = Σ_k cHn[n+1, k+1] * x^k / √(2^{n-k} n! √π)\n\nThis is used to convert between normalized Hermite basis and power-law basis.\n\nReturns\n\ncHn: (nmax+1) × (nmax+1) coefficient matrix\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.hermite_expansion-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any, 4}}} where T","page":"Home","title":"PlasmaBO.hermite_expansion","text":"hermite_expansion(\n    fv::AbstractMatrix{T},\n    vz, vx, vtz, vtp;\n    Nz = 16, Nx = 16,\n    dz = zero(T), dx = zero(T)\n) where {T}\n\nCompute Hermite expansion coefficients from gridded distribution function.\n\nExpands arbitrary 2D distribution f(vparallel, vperp) as:\n\nf(vz, vx) = Σ_{l=0}^{Nz} Σ_{m=0}^{Nx} a_{l,m} * ρ_l(vz) * u_m(vx)\n\nwhere ρl and um are normalized Hermite basis functions. Nz, Nx are the maximum parallel and perpendicular Hermite indices, respectively.\n\nArguments\n\nfv: Distribution function values on (vz, vx) grid\nvz: Parallel velocity grid (1D or matches fv size)\nvx: Perpendicular velocity grid (1D or matches fv size)\nvtz: Parallel thermal velocity (default: 1.0)\nvtp: Perpendicular thermal velocity (default: 1.0)\ndz: Parallel drift velocity (default: 0.0)\ndx: Perpendicular drift velocity (default: 0.0)\n\nReturns\n\nNamed tuple with:\n\nalm: (Nz+1) × (Nx+1) coefficient matrix in power-law basis\na0lm: (Nz+1) × (Nx+1) coefficient matrix in Hermite basis\n\nAlgorithm\n\nCompute a0_{l,m} via numerical integration:\na0_{l,m} = ∫∫ f(z,x) ρ_l(z) u_m(x) dz dx * (2/(Lz*Lx))\nNormalize by distribution integral\nConvert to power-law basis: a{l,m} = hermitea0toa(a0_{l,m})\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.solve_dispersion_matrix","page":"Home","title":"PlasmaBO.solve_dispersion_matrix","text":"solve_dispersion_matrix(params, kx, kz; J=8)\n\nSolve the kinetic dispersion relation using the matrix eigenvalue method.\n\nReturns all eigenfrequencies ω(k) for the given wave vector (kx, kz).\n\nThis method transforms the dispersion relation into a matrix eigenvalue problem using J-pole approximation for the plasma dispersion function, allowing simultaneous computation of all wave modes.\n\nkx: Perpendicular wave vector component (m⁻¹)\nkz: Parallel wave vector component (m⁻¹)\nJ: Number of poles for Z-function approximation (default: 8)\n\nSee also: get_jpole_coefficients\n\n\n\n\n\n","category":"function"},{"location":"#PlasmaBO.solve_fluid_dispersion-NTuple{4, Any}","page":"Home","title":"PlasmaBO.solve_fluid_dispersion","text":"solve_fluid_dispersion(species, B0, kx, kz)\n\nSolve the multi-fluid electromagnetic dispersion relation using matrix eigenvalue method.\n\nReturns all eigenfrequencies ω(k) for the given wave vector (kx, kz).\n\nThe fluid model includes:\n\nContinuity equation: ∂n/∂t + ∇·(nv) = 0\nMomentum equation: m(∂v/∂t + v·∇v) = q(E + v×B) - ∇P/n\nMaxwell's equations for E and B\n\nSee also: FluidSpecies\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.track-Tuple{Any, BranchPoint}","page":"Home","title":"PlasmaBO.track","text":"track(solution, point)\n\nTrack a single dispersion branch across parameter space from initial point.\n\nThe algorithm:\n\nStart at the k-point nearest to the initial point\nTrack bidirectionally using interpolation to predict ω at each k\nSelect nearest eigenvalue to prediction\n\nExample\n\ninitial = BranchPoint(0.03, 0.1721im)\nk_branch, ω_branch = track(solution, initial)\n\nSee also: BranchPoint\n\n\n\n\n\n","category":"method"},{"location":"firehose_Astfalk17/#Case:-Firehose-instability-(kappa-distribution)","page":"Firehose instability","title":"Case: Firehose instability (kappa distribution)","text":"This page demonstrates test firehose instability using Hermite-Hermite (HH) expansion for bi-kappa distribution. \n\nHere we first generate numerical samples of the distribution function using gen_fv2d. Then we use hermite_expansion to compute the Hermite expansion coefficients (this would also work for arbitrary distributions).\n\nusing PlasmaBO\n\nB0 = 0.1  # [Tesla]\nθ = deg2rad(45)\nn = 5.0e19\n\nelectron = Maxwellian(:e, n, 496.683)\n\nκz = 5.5\nκx = 5.5\nproton = BiKappa2(5.e19, κz, κx, 1986.734, 993.367)\ndata = gen_fv2d(proton)\n\nalm = hermite_expansion(data.fv, data.vz, data.vx, data.vtz, data.vtx).alm\nproton_param = HHSolverParam(proton, B0; alm = alm)\n\nkn = 31.0613\nk = kn / 4\nwci = proton_param.wc\nspecies = (proton_param, electron)\n\nωs = solve_kinetic_dispersion(species, B0, k .* sincos(θ)...; N = 2, J = 24)\nω_unstable = filter(ω -> isfinite(ω) && imag(ω) > 0.001 * wci, ωs)\nprintln(\"Unstable modes (ω/ωci): \", ω_unstable ./ wci)","category":"section"},{"location":"firehose_Astfalk17/#Dispersion-Curve-Scan","page":"Firehose instability","title":"Dispersion Curve Scan","text":"k_ranges = (0.05:0.02:0.5) .* kn;\nsol = solve_kinetic_dispersion(species, B0, k_ranges, θ; N = 2, J = 24);\n\nusing CairoMakie\n\nlet\n    f, (ax, ax2) = plot(sol, kn, wci)\n    ylims!(ax, [0, 1])\n    ylims!(ax2, [-0.1, 0.1])\n    f\nend","category":"section"}]
}
