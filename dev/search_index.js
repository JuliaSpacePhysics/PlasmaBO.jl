var documenterSearchIndex = {"docs":
[{"location":"dispersion_surface/#Case:-Dispersion-surface-tracking-(2D-scan)","page":"Dispersion surface tracking","title":"Case: Dispersion surface tracking (2D scan)","text":"This page demonstrates how to construct a dispersion surface by scanning a 2D parameter space (wave number k and propagation angle θ) and using branch tracking to follow a consistent mode across the scan.\n\nWe consider a typical electron–proton plasma and scan:\n\nk in normalized units k/k_n, where k_n = ω_pi/c\nθ from 5° to 90°\n\nusing PlasmaBO\nusing PlasmaBO: c0\n\nB0 = 5e-9 # [Tesla]\n\nn = 5.0e6\nT = 12.94\n\nion = Maxwellian(:p, n, T)\nelectron = Maxwellian(:e, n, T)\nspecies = (ion, electron)\n\nwn = abs(B0 * ion.q / ion.m)\nwpi = plasma_frequency(ion.q, n, ion.m)\nkn = wpi / c0\nwci = wn\n\n# Kinetic solver settings (adjust upward for accuracy)\nN = 3","category":"section"},{"location":"dispersion_surface/#Dispersion-Curve-Scan","page":"Dispersion surface tracking","title":"Dispersion Curve Scan","text":"using CairoMakie\n\nθ = deg2rad(45);\nk_ranges = (0.01:1:100) .* kn;\nresults = solve(species, B0, k_ranges, θ; N)\n\nplot(results, kn, wn)\n\nusing PlasmaBO: plot_branches\n\n# k, ω pairs for initial branch points (see `BranchPoint` for more control over tracking)\ninitial_point = (50 * kn, -600 * wn *im)\nbranch = track(results, initial_point)\nf, (ax1, ax2) = plot_branches((branch,), kn, wn)\nylims!(ax2, -3500,500)\nf","category":"section"},{"location":"dispersion_surface/#Dispersion-Surface-Scan-(2D)","page":"Dispersion surface tracking","title":"Dispersion Surface Scan (2D)","text":"ks = (0.1:10:100.0) .* kn;\nθs = deg2rad.(10.0:10.0:90.0);\nres2d = solve(species, B0, ks, θs; N)\n\nplot(res2d, kn, wn)\n\n# Choose a reference angle and reference k for seeding the tracked mode\nseed = (90.5 * kn, deg2rad(20), (1000 - 3000im) * wn)\nbranch = track(res2d, seed)\nplot_branches((branch,), kn, wn)","category":"section"},{"location":"ice_Irvine18/#Case:-Ion-cyclotron-emission","page":"Ion cyclotron emission","title":"Case: Ion cyclotron emission","text":"Ion cyclotron emission (ICE) driven by a ring ion beam distribution in a magnetized fusion device\n\nusing PlasmaBO\nusing PlasmaBO: gyrofrequency, Alfven_speed\n\nusing DelimitedFiles\n\n# Magnetic field (Tesla)\nB0 = 2.1\n\n# Wave vector angle between k and B0\nθ = deg2rad(89.5)\n\n# Species table taken from the original BO MATLAB input\nfpath = pkgdir(PlasmaBO, \"test/ice_Irvine18.in\")\nreaddlm(fpath)","category":"section"},{"location":"ice_Irvine18/#Dispersion-Curve-Scan","page":"Ion cyclotron emission","title":"Dispersion Curve Scan","text":"tbl = readdlm(fpath, Float64; skipstart = 1)\nspecies = map(eachrow(tbl)) do row\n    Z, A, n_s, Tz_s, Tp_s, vdz_s, vdr_s = row[1:7]\n    Maxwellian(n_s, Tz_s, Tp_s; vdz = vdz_s, vdr = vdr_s, Z , A)\nend\n\nωn = gyrofrequency(B0, species[1])\nvA = Alfven_speed(B0, species)\nkn = ωn / vA\n\nks = (9.5:0.025:11.5) .* kn\nresults = solve(species, B0, ks, θ; N = 12, J = 4)\n\nusing CairoMakie\n\nf, (ax, ax2) = plot(results, kn, ωn)\nylims!(ax, [0, 15])\nylims!(ax2, [-0.5, 0.5])\nf","category":"section"},{"location":"math_notes/#Modified-plasma-dispersion-function","page":"-","title":"Modified plasma dispersion function","text":"The modified plasma dispersion function introduced by Summers and Thorne are defined as\n\n$\n\nZ{\\kappa{\\|}}\\left(\\xin\\right)=\\frac{\\Gamma\\left(\\kappa{\\|s}+1\\right)}{\\sqrt{\\pi \\kappa{\\|s^3}^3 \\Gamma}\\left(\\kappa{\\|s}-1 / 2\\right)} \\int{-\\infty}^{\\infty} \\frac{d x}{\\left(x-\\xin\\right)\\left(1+x^2 / \\kappa{\\|s}\\right)^{\\kappa{\\| s}+1}}, \\quad \\Im(\\xi)>0 $\n\nwith x=left(v_-u_s 0right)  theta_ s and xi_n=left(omega-n omega_c s-k_ u_s 0right)  k_ theta_ s. For any positive integer kappa__s, and all xi_n neq pm i sqrtkappa_ s, the expressions for these dispersion functions can be given using closed-form expansions [24, 7],\n\n$\n\nZ{\\kappa{\\|}}\\left(\\xin\\right)=\\frac{i\\left(\\kappa{\\| s}-1 / 2\\right)}{2 \\kappa{\\| s}^{3 / 2}} \\frac{\\kappa{\\| s}!}{\\left(2 \\kappa{\\| \\|s}\\right)!} \\sum{l=1}^{\\kappa{\\| s}+1} \\frac{\\left(\\kappa{\\| s}+l-1\\right)!}{(l-1)!}\\left(\\frac{2 i}{\\left(\\xin / \\sqrt{\\kappa{\\|s}}\\right)+i}\\right)^{\\kappa_{\\| s}-l+2} . $","category":"section"},{"location":"mirror_mode/#Case:-Mirror-mode","page":"Mirror mode","title":"Case: Mirror mode","text":"The benchmark is based on Gary (1993), p131, Fig.7.4, with\n\nPropagation angle: θ = 71°\nBeta ratio: β_iβ_e = 1\nTemperature anisotropy:\nions: T_iT_i = 2\nelectrons: T_eT_e = 1\nMagnetic field: B_0 = 100e-9 T\nSpecies:\nq = -1, m = 1/1836, n = 1e6, T∥ = 24840 eV, T⊥ = 24840 eV, v0 = 0\nq = +1, m = 1, n = 1e6, T∥ = 24840 eV, T⊥ = 49680 eV, v0 = 0\n\nusing PlasmaBO\n\nB0 = 100e-9\nθ = deg2rad(71)\n\nn = 1e6\nme_mp = 1 / 1836\n\nelectron = Maxwellian(:e, n, 24840.0)\nproton   = Maxwellian(n, 24840.0, 49680.0)\n\nspecies = (proton, electron)\nparams = HHSolverParam.(species, B0)\nρᵢ = params[1].ρc\nωₙ = params[1].wc\nks = (0.005:0.04:0.7) ./ ρᵢ\n\nsol = solve(species, B0, ks, θ)\n\n# Extract the most unstable mode at each k (by growth rate)\nωmax = vec(argmax.(imag, sol.ωs))\n\nusing CairoMakie\n\nlet fig = Figure()\n    ax1 = Axis(fig[1,1]; xlabel = \"k*λD\", ylabel = \"ωᵣ / ωₙ\")\n    ax2 = Axis(fig[1,2]; xlabel = \"k*λD\", ylabel = \"γ / ωₙ\")\n    scatterlines!(ax1, sol.ks .* ρᵢ, real.(ωmax)./ ωₙ)\n    scatterlines!(ax2, sol.ks .* ρᵢ, imag.(ωmax)./ ωₙ)\n    fig\nend","category":"section"},{"location":"ringbeam_Umeda12/#Case:-Ring-beam-instability","page":"Ring beam instability","title":"Case: Ring beam instability","text":"This page demonstrates how to use the package to solve kinetic dispersion relations for the ring beam instability Umeda et al. [6].\n\nusing PlasmaBO\nusing PlasmaBO: q, me\nusing Unitful\n\n# Umeda 2012 ring beam configuration\nB0 = 96.24e-9  # [Tesla]\n\nT = 51u\"eV\"\n# Ring beam electrons (10% density)\n# The first argument (optional) indicates particle type of the distribution (by default we use `proton`)\nring_beam = Maxwellian(:e, 1e5, T; vdz=0.1, vdr=0.05)\n# Background electrons (90% density)\nbackground = Maxwellian(:e, 9e5, T)\n\nspecies = [ring_beam, background]\n\n# Compute normalization\nwce = abs(B0 * q / me)\nlambdaD = Debye_length(species)\nkn = 1 / lambdaD\n\n# Wave vector: k*λD = 0.03, θ = 40°\nk = 0.03 / lambdaD\nθ = deg2rad(40)\nkx = k * sin(θ)\nkz = k * cos(θ)\n\n# J=12 provides good accuracy (J-pole approximation order)\nωs = solve(species, B0, kx, kz; N=6, J=12)\n\n# Filter for unstable modes (ω/ωce) with positive growth rate\nω_unstable = filter(ω -> isfinite(ω) && imag(ω) > 0.001*wce, ωs)[1] ./wce","category":"section"},{"location":"ringbeam_Umeda12/#Dispersion-Curve-Scan","page":"Ring beam instability","title":"Dispersion Curve Scan","text":"Scan k*λD from 0.01 to 0.3\n\nk_ranges = (0.01:0.005:0.3) .* kn;\nsol = solve(species, B0, k_ranges, θ; N=6)\n\n# k, ω pairs for initial branch points (see `BranchPoint` for more control over tracking)\ninitial_points = [\n    (0.1 * kn, 0.3im * wce),\n    (0.1 * kn, 0.1im * wce),\n    (0.2 * kn, 0.25im * wce)\n]\n\nbranches = track.(sol, initial_points)\n\n# Extract individual branches\nfor (i, (k_branch, ω_branch)) in enumerate(branches)\n    println(\"Branch $i:\")\n    println(\"  k range: $(minimum(k_branch)) to $(maximum(k_branch))\")\n    println(\"  Max growth rate: γ = $(maximum(imag.(ω_branch)))\")\nend\n\nPlot all branches\n\nusing CairoMakie\n\nplot_branches(branches, kn, wce)","category":"section"},{"location":"rlp_Cattaert07/#Case:-R-,-L-,-and-P-mode-waves","page":"R/L/P modes (PBK solver)","title":"Case: R-, L-, and P-mode waves","text":"This page reproduces the “case 1” benchmark (Cattaert et al. [7]) in BO-PBK Bai and Xie [8] for the R-, L-, and P-mode branches.\n\nThe configuration is a single electron population with a strongly non-Maxwellian parallel kappa index (κ∥ = 1) and nearly Maxwellian perpendicular index (κ⟂ = 200), with oblique propagation at θ = 30.","category":"section"},{"location":"rlp_Cattaert07/#Setup","page":"R/L/P modes (PBK solver)","title":"Setup","text":"using PlasmaBO\nusing PlasmaBO: q, me\n\nB0 = 1.0e-6          # [Tesla]\nθ = deg2rad(30)\n\nn = 2.43e6           # [m^-3]\nT = 2555.0           # [eV]\nκz = 1.0\nκx = 200.0\n\nelectron = BiKappa2(:e, n, κz, κx, T; sigma = 0.0)\nwce = abs(B0 * q / me)\nρce = electron.vtp / wce\nkn = 1 / ρce  # so that k/kn = kρce\n\nkρ_scan = range(1.0e-4, 0.3; length = 80)\nks = kρ_scan .* kn","category":"section"},{"location":"rlp_Cattaert07/#Analytic-PBK-(BO-PBK)-solver","page":"R/L/P modes (PBK solver)","title":"Analytic PBK (BO-PBK) solver","text":"Solve the same case with the analytic PBK (BO-PBK) solver:\n\nsol_pbk = solve(electron, B0, ks, θ, BOPBK);\n\nusing CairoMakie\n\nf, axs = plot(sol_pbk, kn, wce)\nylims!(axs[1], 0, 3)\nf","category":"section"},{"location":"rlp_Cattaert07/#Plot-the-tracked-PBK-branches:","page":"R/L/P modes (PBK solver)","title":"Plot the tracked PBK branches:","text":"Seeds at kρce = 0.1 are used to identify the branches: upper R-X, O(P), L-X, lower R-X\n\nseed_kρ = 0.1\nseeds_ω = [1.37366, 1.07271, 0.75519, 0.39861] .* wce\n\ninitial_points = [(seed_kρ * kn, ω0) for ω0 in seeds_ω]\nbranches_pbk = track.(sol_pbk, initial_points)\n\nf, (ax1, ax2) = plot_branches(branches_pbk, kn, wce)\nylims!(ax1, nothing, 3)\nylims!(ax2, -0.01, 0.001)\nf","category":"section"},{"location":"rlp_Cattaert07/#General-HH-solver","page":"R/L/P modes (PBK solver)","title":"General HH solver","text":"Solve the same case with the general Hermite-Hermite (HH) basis solver:\n\nusing CairoMakie\n\nsol_HH = solve(electron, B0, ks, θ; N = 4, J = 16)\nbranches_HH = track.(sol_HH, initial_points)\n\nf, axs = plot(sol_HH, kn, wce)\nylims!(axs[1], 0, 3)\nf\n\nPlot the tracked branches\n\nplot_branches(branches_HH, kn, wce)\n\nWe can see that the results from the HH solver is very different than the PBK solver. It does not yield the same branches as the PBK solver due to the small parallel kappa index.\n\nAs a comparison, we solve it for a Maxwellian electron population:\n\nelectron = Maxwellian(:e, n, T)\nsol_M = solve([electron], B0, ks, θ; N = 3)\n\nf, axs = plot(sol_M, kn, wce)\nylims!(axs[1], 0, 3)\nf","category":"section"},{"location":"cold_plasma/#Case:-Cold-plasma-(kinetic-vs-fluid)","page":"Cold plasma (fluid vs kinetic solver)","title":"Case: Cold plasma (kinetic vs fluid)","text":"This page demonstrates a typical cold plasma configuration (electron–proton plasma) and compares the eigenmodes computed by the kinetic solver (solve) and the multi-fluid solver (solve with BOFluid).\n\nThe input parameters correspond to the following species table:\n\nspecies n (m⁻³) T (eV)\nions (p) 8.7e6 2.857e-3\nelectrons (e) 8.7e6 2.857e-3\n\nWe scan k at fixed propagation angle θ = 60°.\n\nusing PlasmaBO\nusing PlasmaBO: q, me, mp, c0\n\nB0 = 100e-9 # [Tesla]\nθ = deg2rad(60)\n\nn = 8.7e6\nT = 2.857e-3\n\nion = Maxwellian(:p, n, T)\nelectron = Maxwellian(:e, n, T)\nspecies = (ion, electron)\n# For more control over the fluid model, we can use `FluidSpecies`\n# electron_f = FluidSpecies(:e, n, T; gamma_z = 1.0, gamma_p = 1.0)\n\nwci = abs(B0 * q / mp)\nwpi = plasma_frequency(q, n, mp)\nkn = wpi / c0","category":"section"},{"location":"cold_plasma/#Dispersion-Curve-Scan","page":"Cold plasma (fluid vs kinetic solver)","title":"Dispersion Curve Scan","text":"kn_scan = 0.01:2.0:100.0;\nks = kn_scan .* kn;\nkinetic = solve(species, B0, ks, θ);\nfluid_ωs = solve(species, B0, ks, θ, BOFluid);\n\nusing CairoMakie\n\nlet\n    fig = Figure(size = (900, 360))\n    ax1 = Axis(fig[1, 1], xlabel = \"k [k_n]\", ylabel = \"Re(ω)/ω_ci\")\n    ax2 = Axis(fig[1, 2], xlabel = \"k [k_n]\", ylabel = \"Im(ω)/ω_ci\")\n\n    for (k_norm, ωs_k, ωs_f) in zip(kn_scan, kinetic.ωs, fluid_ωs.ωs)\n        xk = fill(k_norm, length(ωs_k))\n        xf = fill(k_norm, length(ωs_f))\n\n        scatter!(ax1, xk, real.(ωs_k) ./ wci; color=:transparent, strokecolor = (:blue, 0.35), strokewidth=2, marker = :circle)\n        scatter!(ax1, xf .+ 0.05, real.(ωs_f) ./ wci; color=:red, marker = :cross)\n\n        scatter!(ax2, xk, imag.(ωs_k) ./ wci; color=:transparent, strokecolor = (:blue, 0.35), strokewidth=2, marker = :circle)\n        scatter!(ax2, xf .+ 0.05, imag.(ωs_f) ./ wci; color=:red, marker = :cross)\n    end\n    fig\nend\n\nRed crosses: Fluid solver results.\n\nBlue circles: Kinetic solver results.\n\nThere is a slight difference at large k for the ion cyclotron wave, which is damped due to kinetic effect.","category":"section"},{"location":"#PlasmaBO","page":"Home","title":"PlasmaBO","text":"(Image: DOI) (Image: version)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"PlasmaBO\")","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Hermite-Hermite (BO-HH) expansion solver for arbitrary/analytic distributions\nMaxwellian / BiMaxwellian\nAnalytic Product-Bi-Kappa (BO-PBK) solver\nMulti-fluid solver\nIntegration with ChargedParticles.jl","category":"section"},{"location":"#Usage-Examples","page":"Home","title":"Usage Examples","text":"The matrix eigenvalue method (Xie [1], Xie and Xiao [2]) finds all wave modes simultaneously by transforming the dispersion relation into a matrix eigenvalue problem using J-pole approximation for the plasma dispersion function.\n\nThis approach is more efficient to find multiple modes at once, and doesn't require initial guesses for the root finder.\n\nCheck out the ring beam instability example for detailed usage instructions, also see firehose instability example for using with arbitrary velocity distributions, BO-PBK example for using with kappa distributions (BO-PBK), cold plasma example for comparing kinetic and fluid solvers, and dispersion surface tracking example for 2D scanning and mode tracking.","category":"section"},{"location":"#Solvers","page":"Home","title":"Solvers","text":"BO-PBK (BOPBK) is an analytic, distribution-aware eigen-solver optimized for kappa plasmas, whereas BO-Arbitrary (BOHH) is a universal but numerically heavier framework that approximates any distribution at the cost of efficiency and low-κ accuracy.","category":"section"},{"location":"#Notation-and-Assumptions","page":"Home","title":"Notation & Assumptions","text":"The formulation (code) is valid for non-relativistic, arbitrary gyrotropic distributions.\n\nCoordinates\nz: direction parallel to the background magnetic field (B0).\nx: one perpendicular direction (any perpendicular direction is equivalent).\nVelocities\nvz, vx: particle velocity components along z and x.\nvdz, vdx: drift/bulk velocity components along z and x (when present in a distribution parameterization).\nvtz, vtx: thermal speeds along z and x.\nWave vector\nθ: propagation angle between k and B0.\nk∥ = k cos(θ), k⊥ = k sin(θ).","category":"section"},{"location":"#References","page":"Home","title":"References","text":"Xie et al. [3], Xie [4], Xie [5], \n\nH. Xie. Efficient Framework for Solving Plasma Waves with Arbitrary Distributions. Physics of Plasmas 32, 60702 (2025).\n\n\n\nH. Xie and Y. Xiao. PDRK: A General Kinetic Dispersion Relation Solver for Magnetized Plasma*. Plasma Science and Technology 18, 97 (2016).\n\n\n\nH.-s. Xie, R. Denton, J.-s. Zhao and W. Liu. BO 2.0: Plasma Wave and Instability Analysis with Enhanced Polarization Calculations (Mar 2021), arXiv:2103.16014 [physics].\n\n\n\nH.-s. Xie. PDRF: A General Dispersion Relation Solver for Magnetized Multi-Fluid Plasma. Computer Physics Communications 185, 670–675 (2014).\n\n\n\nH.-S. (. Xie. Generalized Plasma Dispersion Function: One-Solve-All Treatment, Visualizations, and Application to Landau Damping. Physics of Plasmas 20, 92125 (2013).\n\n\n\nT. Umeda, S. Matsukiyo, T. Amano and Y. Miyoshi. A Numerical Electromagnetic Linear Dispersion Relation for Maxwellian Ring-Beam Velocity Distributions. Physics of Plasmas 19, 72107 (2012).\n\n\n\nT. Cattaert, M. A. Hellberg and R. L. Mace. Oblique Propagation of Electromagnetic Waves in a Kappa-Maxwellian Plasma. Physics of Plasmas 14, 82111 (2007).\n\n\n\nW. Bai and H. Xie. BO-PBK: A Comprehensive Solver for Dispersion Relations of Obliquely Propagating Waves in Magnetized Multi-Species Plasma with Anisotropic Loss-Cone Drift Product-Bi-Kappa Distribution (Dec 2025), arXiv:2512.06901 [physics].\n\n\n\n","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"#PlasmaBO.BOPBK-index","page":"Home","title":"PlasmaBO.BOPBK","text":"BOPBK(; N = 2)\n\nDispersion solver using the PBK matrix formulation.\n\nN controls the truncation order of the cyclotron harmonic index used to build the dispersion matrix.\n\n\n\n\n\n","category":"type"},{"location":"#PlasmaBO.BOHH-index","page":"Home","title":"PlasmaBO.BOHH","text":"BOHH(; N = 2, J = 8)\n\nDispersion solver using the Hermite-Hankel (HH) matrix formulation.\n\nN controls the truncation order of the cyclotron harmonic index. J controls the truncation order of the Hermite expansion used in the solver.\n\n\n\n\n\n","category":"type"},{"location":"#PlasmaBO.BOFluid-index","page":"Home","title":"PlasmaBO.BOFluid","text":"BOFluid()\n\nDispersion solver using the multi-fluid electromagnetic matrix formulation.\n\n\n\n\n\n","category":"type"},{"location":"#PlasmaBO.BOFluid","page":"Home","title":"PlasmaBO.BOFluid","text":"BOFluid()\n\nDispersion solver using the multi-fluid electromagnetic matrix formulation.\n\n\n\n\n\n","category":"type"},{"location":"#PlasmaBO.BOHH","page":"Home","title":"PlasmaBO.BOHH","text":"BOHH(; N = 2, J = 8)\n\nDispersion solver using the Hermite-Hankel (HH) matrix formulation.\n\nN controls the truncation order of the cyclotron harmonic index. J controls the truncation order of the Hermite expansion used in the solver.\n\n\n\n\n\n","category":"type"},{"location":"#PlasmaBO.BOPBK","page":"Home","title":"PlasmaBO.BOPBK","text":"BOPBK(; N = 2)\n\nDispersion solver using the PBK matrix formulation.\n\nN controls the truncation order of the cyclotron harmonic index used to build the dispersion matrix.\n\n\n\n\n\n","category":"type"},{"location":"#PlasmaBO.BranchPoint","page":"Home","title":"PlasmaBO.BranchPoint","text":"BranchPoint{T}\nBranchPoint(k, ω)\n\nInitial point specification for dispersion branch tracking.\n\nFields\n\nk: Wave vector at initial point\nω: Frequency at initial point\nlocator: Callable used to locate the seed eigenvalue at the initial point\n\nExample\n\n# Track unstable branch starting at k=0.03 with γ=0.1721\npoint1 = BranchPoint(0.03, 0.1721im)     # Auto: track by Im\n\n# Track real frequency mode at k=0.5 with ωᵣ=2.5\npoint2 = BranchPoint(0.5, 2.5)  # Auto: track by Re\n\n\n\n\n\n","category":"type"},{"location":"#PlasmaBO.FluidSpecies","page":"Home","title":"PlasmaBO.FluidSpecies","text":"FluidSpecies(n, Tz, Tp = Tz; vdz=0.0, gamma_z=1.0, gamma_p=1.0, particle=:p, ...)\n\n\n\n\n\n","category":"type"},{"location":"#PlasmaBO.FluidSpecies-2","page":"Home","title":"PlasmaBO.FluidSpecies","text":"FluidSpecies{T}\n\nFluid species parameters for the multi-fluid dispersion relation solver.\n\nFields\n\nq: Charge\nm: Mass\nn: Number density (m⁻³)\nTz: Parallel temperature (eV)\nTp: Perpendicular temperature (eV)\nvdz: Parallel drift velocity (in units of c)\ngamma_z: Parallel polytrope exponent (default: 1.0 for isothermal)\ngamma_p: Perpendicular polytrope exponent (default: 1.0 for isothermal)\n\n\n\n\n\n","category":"type"},{"location":"#PlasmaBO.JPoleCoefficients","page":"Home","title":"PlasmaBO.JPoleCoefficients","text":"JPoleCoefficients{T}\n\nJ-pole approximation coefficients for the plasma dispersion function. Z(ζ) ≈ Σⱼ bⱼ/(ζ - cⱼ)\n\n\n\n\n\n","category":"type"},{"location":"#PlasmaBO.funAn-NTuple{5, Any}","page":"Home","title":"PlasmaBO.funAn","text":"funAn(n, a, d, m, p)\n\nPerpendicular integral for Jn²: ∫ Jn²(ay) exp(-(y-d)²) (y-d)^m y^p dy.\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.funBn-NTuple{5, Any}","page":"Home","title":"PlasmaBO.funBn","text":"funBn(n, a, d, m, p)\n\nPerpendicular integral for Jn·Jn': ∫ Jn(ay) Jn'(ay) exp(-(y-d)²) (y-d)^m y^p dy.\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.funCn-NTuple{5, Any}","page":"Home","title":"PlasmaBO.funCn","text":"funCn(n, a, d, m, p)\n\nPerpendicular integral for (Jn')²: ∫ [Jn'(ay)]² exp(-(y-d)²) (y-d)^m y^p dy.\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.funIn-Tuple{Any}","page":"Home","title":"PlasmaBO.funIn","text":"funIn(n)\n\nNormalization integral I_n = ∫ v^n exp(-v²) dv / √π.\n\nReturns Γ((n+1)/2)/√π for even n, 0 for odd n.\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.get_jpole_coefficients","page":"Home","title":"PlasmaBO.get_jpole_coefficients","text":"get_jpole_coefficients(J=8)\n\nGet J-pole approximation coefficients for the plasma dispersion function.\n\nSupported values: J ∈ {4, 6, 8, 10, 12, 16, 20, 24, 28, 32}\n\n\n\n\n\n","category":"function"},{"location":"#PlasmaBO.hermite_H-Union{Tuple{T}, Tuple{Int64, T}} where T<:Number","page":"Home","title":"PlasmaBO.hermite_H","text":"hermite_H(n::Int, x)\n\nCompute physicists' Hermite polynomial H_n(x) using recurrence relation.\n\nRecurrence Relations\n\nH_0(x) = 1\nH_1(x) = 2x\nH{n+1}(x) = 2x*Hn(x) - 2n*H_{n-1}(x)\n\nExamples\n\nhermite_H(0, 1.5)  # Returns 1.0\nhermite_H(1, 1.5)  # Returns 3.0 (= 2*1.5)\nhermite_H(2, 1.5)  # Returns 7.0 (= 2*1.5*3.0 - 2*1*1.0)\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.hermite_a0_to_a-Tuple{Any}","page":"Home","title":"PlasmaBO.hermite_a0_to_a","text":"hermite_a0_to_a(a0lm)\n\nConvert normalized Hermite basis coefficients: a0lm -> alm\n\nTransforms expansion:\n\nf(z,x) = Σ_{l,m} a0_{l,m} * ρ_l(z) * u_m(x)\n\nto:\n\nf(z,x) = Σ_{l,m} a_{l,m} * g_l(z) * h_m(x)\n\nwhere:\n\nρl, um are normalized Hermite functions\ng_l(z) ∝ z^l * exp(-z²/2)\nh_m(x) ∝ x^m * exp(-x²/2)\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.hermite_coefficients_matrix-Tuple{Any}","page":"Home","title":"PlasmaBO.hermite_coefficients_matrix","text":"hermite_coefficients_matrix(nmax)\n\nCompute coefficient matrix for expanding Hermite polynomials in power basis given the maximum order nmax.\n\nReturns matrix cHn[n+1, k+1] such that:\n\nH_n(x) / √(2^n n! √π) = Σ_k cHn[n+1, k+1] * x^k / √(2^{n-k} n! √π)\n\nThis is used to convert between normalized Hermite basis and power-law basis.\n\nReturns\n\ncHn: (nmax+1) × (nmax+1) coefficient matrix\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.hermite_expansion-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any, 4}}} where T","page":"Home","title":"PlasmaBO.hermite_expansion","text":"hermite_expansion(\n    fv::AbstractMatrix{T},\n    vz, vx, vtz, vtp;\n    Nz = 16, Nx = 16,\n    dz = zero(T), dx = zero(T)\n) where {T}\n\nCompute Hermite expansion coefficients from gridded distribution function.\n\nExpands arbitrary 2D distribution f(vparallel, vperp) as:\n\nf(vz, vx) = Σ_{l=0}^{Nz} Σ_{m=0}^{Nx} a_{l,m} * ρ_l(vz) * u_m(vx)\n\nwhere ρl and um are normalized Hermite basis functions. Nz, Nx are the maximum parallel and perpendicular Hermite indices, respectively.\n\nArguments\n\nfv: Distribution function values on (vz, vx) grid\nvz: Parallel velocity grid (1D or matches fv size)\nvx: Perpendicular velocity grid (1D or matches fv size)\nvtz: Parallel thermal velocity (default: 1.0)\nvtp: Perpendicular thermal velocity (default: 1.0)\ndz: Parallel drift velocity (default: 0.0)\ndx: Perpendicular drift velocity (default: 0.0)\n\nReturns\n\nNamed tuple with:\n\nalm: (Nz+1) × (Nx+1) coefficient matrix in power-law basis\na0lm: (Nz+1) × (Nx+1) coefficient matrix in Hermite basis\n\nAlgorithm\n\nCompute a0_{l,m} via numerical integration:\na0_{l,m} = ∫∫ f(z,x) ρ_l(z) u_m(x) dz dx * (2/(Lz*Lx))\nNormalize by distribution integral\nConvert to power-law basis: a{l,m} = hermitea0toa(a0_{l,m})\n\n\n\n\n\n","category":"method"},{"location":"#PlasmaBO.solve_dispersion_matrix","page":"Home","title":"PlasmaBO.solve_dispersion_matrix","text":"solve_dispersion_matrix(params, kx, kz; N=2, J=8)\n\nSolve the kinetic dispersion relation using the matrix eigenvalue method.\n\nReturns all eigenfrequencies ω(k) for the given wave vector (kx, kz).\n\nThis method transforms the dispersion relation into a matrix eigenvalue problem using J-pole approximation for the plasma dispersion function, allowing simultaneous computation of all wave modes.\n\nkx: Perpendicular wave vector component (m⁻¹)\nkz: Parallel wave vector component (m⁻¹)\nJ: Number of poles for Z-function approximation (default: 8)\n\nSee also: get_jpole_coefficients\n\n\n\n\n\n","category":"function"},{"location":"#PlasmaBO.track-Tuple{Any, BranchPoint}","page":"Home","title":"PlasmaBO.track","text":"track(solution, point)\n\nTrack a single dispersion branch across parameter space from initial point.\n\nThe algorithm:\n\nStart at the k-point nearest to the initial point\nTrack bidirectionally using interpolation to predict ω at each k\nSelect nearest eigenvalue to prediction\n\nExample\n\ninitial = BranchPoint(0.03, 0.1721im)\nk_branch, ω_branch = track(solution, initial)\n\nSee also: BranchPoint\n\n\n\n\n\n","category":"method"},{"location":"firehose_Astfalk17/#Case:-Firehose-instability-(kappa-distribution)","page":"Firehose instability","title":"Case: Firehose instability (kappa distribution)","text":"This page demonstrates test firehose instability using Hermite-Hermite (HH) expansion for bi-kappa distribution. \n\nHere we first generate numerical samples of the distribution function using gen_fv2d. Then we use hermite_expansion to compute the Hermite expansion coefficients (this would also work for arbitrary distributions).\n\nusing PlasmaBO\n\nB0 = 0.1  # [Tesla]\nθ = deg2rad(45)\nn = 5.0e19\n\nelectron = Maxwellian(:e, n, 496.683)\n\nκz = 5.5\nκx = 5.5\nproton = BiKappa2(5.e19, κz, κx, 1986.734, 993.367)\ndata = gen_fv2d(proton)\n\nalm = hermite_expansion(data.fv, data.vz, data.vx, data.vtz, data.vtx).alm\nproton_param = HHSolverParam(proton, B0; alm = alm)\n\nkn = 31.0613\nk = kn / 4\nwci = proton_param.wc\nspecies = (proton_param, electron)\n\nωs = solve(species, B0, k .* sincos(θ)...; N = 2, J = 24)\nω_unstable = filter(ω -> isfinite(ω) && imag(ω) > 0.001 * wci, ωs)\nprintln(\"Unstable modes (ω/ωci): \", ω_unstable ./ wci)","category":"section"},{"location":"firehose_Astfalk17/#Dispersion-Curve-Scan","page":"Firehose instability","title":"Dispersion Curve Scan","text":"k_ranges = (0.05:0.02:0.5) .* kn;\nsol = solve(species, B0, k_ranges, θ; N = 2, J = 24);\n\nusing CairoMakie\n\nlet\n    f, (ax, ax2) = plot(sol, kn, wci)\n    ylims!(ax, [0, 1])\n    ylims!(ax2, [-0.1, 0.1])\n    f\nend","category":"section"}]
}
